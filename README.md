# Doctor Appointment API with Analytics and Retry RabbitMQ Processing

## Описание проекта

Это простой FastAPI проект для записи пациентов на приём к врачу с двумя конечными точками (ручками):

- **POST /appointment/** — добавить запись на приём.
- **GET /appointment/** — получить все записи.

Также реализована условная аналитика с использованием **RabbitMQ** и библиотеки `aio_pika`:

- При создании записи отправляются аналитические данные в RabbitMQ через продюсер `RetryProducer`.
- В проекте есть три очереди RabbitMQ для обработки аналитики:
  - Основная очередь.
  - Dead Letter Queue (DLQ) с TTL (временем жизни сообщения).
  - Очередь `not_solved` для сообщений, которые не удалось обработать после нескольких попыток.
- Если обработка сообщения в основной очереди неудачна, задача отправляется в DLQ с задержкой.
- После истечения TTL задача возвращается в основную очередь для повторной попытки.
- Если задача не может быть решена после определённого количества попыток, она уходит в очередь `not_solved` и больше не обрабатывается.

Для обработки сообщений используется консюмер, который запускается отдельно командой:

```bash
python -m analytics.consume
```

---

## Описание API

### POST /appointment

Добавляет запись на приём.

**Тело запроса - json (пример):**
``` 
{
  "patient_name": "Иван Иванов",
  "office_number": "221B",
  "date_time": "2025-12-01T15:30:00"
}
```

**Ответ - json:**

```
{
  "id": 1,
  "patient_name": "Иван Иванов",
  "office_number": "221B",
  "date_time": "2025-12-01T15:30:00"
}
```

При успешном создании записи аналитические данные отправляются в очередь RabbitMQ через `RetryProducer`.

### GET /appointment

Возвращает список всех записей.

**Ответ (пример):**

```json
[
  {
    "id": 1,
    "patient_name": "Иван Иванов",
    "doctor_name": "Др. Петров",
    "appointment_datetime": "2024-07-01T15:30:00"
  },
  {
    "id": 2,
    "patient_name": "Мария Смирнова",
    "doctor_name": "Др. Сидоров",
    "appointment_datetime": "2024-07-02T10:00:00"
  }
]
```

---

## Архитектура RabbitMQ очередей

- **Основная очередь (RMQ_FOR_RETRIES):** сюда поступают новые сообщения аналитики.
- **DLQ (DLQ_FOR_RETRIES):** сообщения с ошибками из основной очереди поступают сюда с TTL задержкой, после истечения которой они возвращаются в основную очередь.
- **not_solved (RMQ_NOT_SOLVED):** сообщения, которые не удалось успешно обработать после заданного числа повторных попыток, попадают сюда и более не обрабатываются.

---

## Установка и запуск

- Клонировать репозиторий:

```bash
git clone https://github.com/professorLumpen/doctor_appointment.git
cd your-project-folder
```
- Установить зависимости:
```
pip install -r requirements.txt
```

- Cоздать файл .env на основе .env.example:


- Запустить RabbitMQ и Postgres через docker-compose:

```
docker-compose up -d
```

- Применить миграции:

```
alembic upgrade head
```

- Запустить FastAPI сервер:

```
fastapi dev main.py
```

## Запуск аналитического консьюмера

Аналитический консьюмер слушает основную очередь и обрабатывает сообщения, включая логику повторных попыток и перевод сообщений между очередями.

Запуск:

```bash
python -m analytics.consume
```